"""MCP Tool definitions for agent skills.

Provides a minimal set of tools with bash as the primary interface.
Skills are exposed as MCP Resources for progressive disclosure.
"""

# pyright: reportUnusedFunction=false

from __future__ import annotations

import asyncio
import json
import shutil
from pathlib import Path
from typing import Any

from mcp.server.fastmcp import FastMCP
from pydantic import Field

from agent_skills.core.executor import Executor
from agent_skills.core.skill_manager import SKILL_FILE_NAME, SkillManager
from agent_skills.core.types import ToolStatus
from agent_skills.mcp.prompts import SKILL_GUIDE_PROMPT
from agent_skills.sandbox.sandbox import Sandbox, SandboxConfig


async def _run_with_uv_isolation(
    scripts_dir: Path,
    command: str,
    timeout: int = 120,
) -> tuple[str, int]:
    """Run a command in an isolated uv virtual environment.

    Creates a temporary virtual environment using uv, installs dependencies
    from pyproject.toml, executes the command, and cleans up the environment.

    Args:
        scripts_dir: Path to the scripts directory containing pyproject.toml
        command: Command to execute (e.g., "python main.py arg1 arg2")
        timeout: Maximum execution time in seconds

    Returns:
        Tuple of (output string, exit code)
    """
    import os

    venv_path = scripts_dir / ".venv"
    output_parts: list[str] = []

    # Create a clean environment without VIRTUAL_ENV to avoid uv warnings
    # about mismatched virtual environments
    clean_env = os.environ.copy()
    clean_env.pop("VIRTUAL_ENV", None)
    clean_env.pop("CONDA_PREFIX", None)
    clean_env.pop("CONDA_DEFAULT_ENV", None)

    try:
        # Step 1: Create venv and install dependencies using uv sync
        # uv sync will create .venv if not exists and install dependencies
        # Note: We don't use --frozen as skills may not have a uv.lock file yet
        sync_process = await asyncio.create_subprocess_exec(
            "uv", "sync", "--quiet",
            cwd=str(scripts_dir),
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
            env=clean_env,
        )
        _, sync_stderr = await asyncio.wait_for(
            sync_process.communicate(),
            timeout=timeout,
        )

        if sync_process.returncode != 0:
            error_msg = sync_stderr.decode("utf-8", errors="replace")
            return f"Failed to setup environment:\n{error_msg}", sync_process.returncode or 1

        # Step 2: Execute the command using uv run
        # uv run automatically uses the project's virtual environment
        run_process = await asyncio.create_subprocess_shell(
            f"uv run {command}",
            cwd=str(scripts_dir),
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
            env=clean_env,
        )
        run_stdout, run_stderr = await asyncio.wait_for(
            run_process.communicate(),
            timeout=timeout,
        )

        stdout_text = run_stdout.decode("utf-8", errors="replace")
        stderr_text = run_stderr.decode("utf-8", errors="replace")

        if stdout_text:
            output_parts.append(stdout_text)
        if stderr_text:
            output_parts.append(stderr_text)

        return "\n".join(output_parts) if output_parts else "", run_process.returncode or 0

    except asyncio.TimeoutError:
        return f"Command timed out after {timeout} seconds", 124

    except Exception as e:
        return f"Execution error: {e}", 1

    finally:
        # Step 3: Clean up - remove the virtual environment and lockfile
        if venv_path.exists():
            try:
                shutil.rmtree(venv_path)
            except Exception:
                pass  # Best effort cleanup
        
        # Also clean up uv.lock file (generated by uv sync)
        lockfile_path = scripts_dir / "uv.lock"
        if lockfile_path.exists():
            try:
                lockfile_path.unlink()
            except Exception:
                pass  # Best effort cleanup


def register_tools(
    mcp: FastMCP,
    sandbox_config: SandboxConfig | None = None,
    skills_dirs: list[str] | None = None,
) -> dict[str, Any]:
    """
    Register all agent-skills tools and resources with an MCP server.

    This registers:
    - 8 tools: bash, bg, jobs, kill, skills_list, skills_read, skills_write, skills_create, skills_run
    - N resources: skill://{name} for each discovered skill

    The skill resources provide progressive disclosure:
    - Resource metadata (name, description) is preloaded for agent awareness
    - Full SKILL.md content is read on-demand when agent needs it

    Args:
        mcp: FastMCP server instance
        sandbox_config: Optional sandbox configuration
        skills_dirs: Optional list of skill directories

    Returns:
        Dictionary of initialized components for reference
    """
    # Initialize components
    sandbox = Sandbox(sandbox_config)
    executor = Executor(sandbox)
    skill_manager = SkillManager(sandbox, skills_dirs)

    # ============================================
    # Skill Resources (Progressive Disclosure)
    # ============================================

    # Define the Skill System Guide Prompt
    @mcp.prompt()
    def skill_guide() -> str:
        """Get a comprehensive guide on how to use and create skills."""
        return SKILL_GUIDE_PROMPT

    # Register each discovered skill as a concrete resource
    # This exposes skill metadata (name, description) in list_resources()
    # so Agent can see all available skills at startup
    def _make_skill_reader(skill_path: str):
        """Factory function to create a skill reader with captured path."""

        def reader() -> str:
            skill_file = Path(skill_path) / SKILL_FILE_NAME
            return skill_file.read_text(encoding="utf-8")

        return reader

    for skill_info in skill_manager.discover_skills():
        # Register each skill as a concrete resource with its metadata
        mcp.resource(
            f"skill://{skill_info.name}",
            name=skill_info.name,
            description=skill_info.description,
            mime_type="text/markdown",
        )(_make_skill_reader(skill_info.path))

    # ============================================
    # Command Execution Tools
    # ============================================

    @mcp.tool()
    async def bash(
        command: str = Field(
            description="Shell command to execute (supports ls, cat, grep, sed, python, etc.)"
        ),
        timeout: int = Field(default=30, description="Maximum execution time in seconds"),
        cwd: str | None = Field(
            default=None, description="Working directory (relative to skills root)"
        ),
    ) -> str:
        """Execute any shell command in the skills sandbox.

        The agent is sandboxed to the skills directory. All paths are relative
        to the skills root. You cannot access files outside the skills directory.

        Examples:
        - bash("ls -la") - list all skills
        - bash("cat gcd-calculator/SKILL.md") - read skill file
        - bash("ls gcd-calculator/scripts/") - list skill scripts
        - bash("python gcd-calculator/scripts/gcd.py 12 18") - run script
        - bash("mkdir my-new-skill") - create new skill directory
        - bash("rm -rf old-skill") - remove a skill
        """
        # Handle FieldInfo objects from direct calls (not via MCP)
        actual_timeout = timeout if isinstance(timeout, int) else 30
        actual_cwd = cwd if isinstance(cwd, str) else None

        result = await executor.bash(command, actual_timeout, actual_cwd)
        output = result.output
        if result.status == ToolStatus.ERROR:
            return f"Exit code: {result.exit_code}\n{output}"
        return output

    @mcp.tool()
    async def bg(
        command: str = Field(description="Shell command to execute in background"),
        cwd: str | None = Field(default=None, description="Working directory"),
    ) -> str:
        """Execute a command in the background.

        Returns the PID of the background process. Use jobs() to check status
        and kill() to terminate.

        Examples:
        - bg("python server.py") - start server in background
        - bg("tail -f app.log") - watch log file
        """
        from agent_skills.core.types import BackgroundTask, CommandResult

        # Handle FieldInfo objects from direct calls
        actual_cwd = cwd if isinstance(cwd, str) else None

        result = await executor.bg(command, actual_cwd)
        if isinstance(result, BackgroundTask):
            return f"Started background process: PID {result.pid}"
        elif isinstance(result, CommandResult):
            return f"Error: {result.stderr}"
        return str(result)

    @mcp.tool()
    def jobs() -> str:
        """List running background tasks.

        Returns information about all background processes started with bg().
        """
        tasks = executor.jobs()
        if not tasks:
            return "No background tasks running"
        lines: list[str] = []
        for task in tasks:
            lines.append(
                f"[{task.pid}] {task.command} (started: {task.started_at.strftime('%H:%M:%S')})"
            )
        return "\n".join(lines)

    @mcp.tool()
    def kill(
        pid: int = Field(description="Process ID to signal"),
        signal: int = Field(default=15, description="Signal number (default: SIGTERM=15)"),
    ) -> str:
        """Send a signal to a process.

        Common signals:
        - 15 (SIGTERM): Graceful termination (default)
        - 9 (SIGKILL): Force kill
        - 2 (SIGINT): Interrupt (like Ctrl+C)

        Examples:
        - kill(12345) - send SIGTERM to process
        - kill(12345, signal=9) - send SIGKILL (force kill)
        """
        result = executor.kill(pid, signal)
        if result.status == ToolStatus.ERROR:
            return f"Error: {result.stderr}"
        return result.stdout

    # ============================================
    # Skill Management Tools (5 separate tools)
    # ============================================

    @mcp.tool()
    def skills_list(
        name: str | None = Field(
            default=None,
            description="Skill name to list files for. If omitted, lists all available skills.",
        ),
        verbose: bool = Field(
            default=False, description="Show detailed info when listing all skills"
        ),
    ) -> str:
        """List skills or files within a skill.

        - No args: list all available skills with names and descriptions
        - With name: list all files in that skill package

        Examples:
        - skills_list() - show all available skills
        - skills_list(verbose=True) - show skills with paths
        - skills_list(name="gcd-calculator") - list files in gcd-calculator skill
        """
        # Handle case where name is a FieldInfo object (direct call without MCP)
        actual_name = name if isinstance(name, str) else None
        actual_verbose = verbose if isinstance(verbose, bool) else False

        if actual_name:
            # List files in a specific skill
            result = skill_manager.list_files(actual_name)
            if result.status == ToolStatus.ERROR:
                return f"Error: {result.message}"
            if result.data:
                if isinstance(result.data, list):
                    return json.dumps(result.data, indent=2, ensure_ascii=False)  # type: ignore[arg-type]
                return str(result.data)
            return result.message
        else:
            # List all skills
            result = skill_manager.list(actual_verbose)
            if result.status == ToolStatus.ERROR:
                return f"Error: {result.message}"
            if result.data:
                return str(result.data)
            return result.message

    @mcp.tool()
    def skills_read(
        name: str = Field(description="Skill name"),
        file: str | None = Field(
            default=None,
            description="File path within skill (e.g., 'scripts/run.py'). If omitted, reads SKILL.md",
        ),
    ) -> str:
        """Read skill content or a specific file within a skill.

        - name only: read the skill's SKILL.md (instructions and metadata)
        - name + file: read a specific file from the skill package

        Examples:
        - skills_read(name="gcd-calculator") - read SKILL.md
        - skills_read(name="gcd-calculator", file="scripts/gcd.py") - read specific file
        """
        # Handle case where file is a FieldInfo object (direct call without MCP)
        actual_file = file if isinstance(file, str) else None

        if actual_file:
            # Read specific file within skill
            result = skill_manager.read_file(name, actual_file)
            if result.status == ToolStatus.ERROR:
                return f"Error: {result.message}"
            if result.data:
                return str(result.data)
            return result.message
        else:
            # Read SKILL.md
            content = skill_manager.read_skill_content(name)
            if content is None:
                return f"Error: skill '{name}' not found."
            return content

    @mcp.tool()
    def skills_write(
        name: str = Field(description="Skill name"),
        file: str = Field(
            description="Relative file path within skill (e.g., 'scripts/run.py')"
        ),
        content: str = Field(description="File content to write"),
    ) -> str:
        """Write/add a file to a skill package.

        Creates parent directories automatically if they don't exist.

        Examples:
        - skills_write(name="my-skill", file="scripts/run.py", content="print('hello')")
        - skills_write(name="my-skill", file="data/config.json", content='{"key": "value"}')
        """
        result = skill_manager.add_file(name, file, content)
        if result.status == ToolStatus.ERROR:
            return f"Error: {result.message}"
        if result.data:
            if isinstance(result.data, dict):
                return json.dumps(result.data, indent=2, ensure_ascii=False)  # type: ignore[arg-type]
            return str(result.data)
        return result.message

    @mcp.tool()
    def skills_create(
        name: str = Field(description="Skill name (lowercase letters, numbers, hyphens)"),
        description: str = Field(description="One-line description of what the skill does"),
        instructions: str = Field(description="Markdown instructions for SKILL.md"),
        path: str | None = Field(
            default=None, description="Custom directory path to create skill in"
        ),
    ) -> str:
        """Create a new skill with auto-validation.

        Creates a skill directory with SKILL.md containing the provided metadata
        and instructions. The skill is automatically validated after creation.

        Naming rules:
        - Use lowercase letters, numbers, and hyphens only
        - Must start with a letter
        - Examples: "code-reviewer", "data-analyzer", "gcd-calculator"

        Examples:
        - skills_create(name="my-tool", description="Does X", instructions="# Usage\\n...")
        """
        # Create the skill
        result = skill_manager.create(name, description, instructions, path)
        if result.status == ToolStatus.ERROR:
            return f"Error: {result.message}"

        # Auto-validate after creation
        result_data = result.data
        if result_data and isinstance(result_data, dict):
            skill_path_value = str(result_data.get("path", ""))  # pyright: ignore[reportUnknownMemberType, reportUnknownArgumentType]
            if skill_path_value:
                validate_result = skill_manager.validate(skill_path_value)
                if validate_result.status == ToolStatus.ERROR:
                    # Return creation success but note validation issues
                    return (
                        f"Created skill '{name}' but validation found issues:\n"
                        f"{validate_result.data or validate_result.message}"
                    )

        if result_data:
            if isinstance(result_data, dict):
                return json.dumps(dict(result_data), indent=2, ensure_ascii=False)  # pyright: ignore[reportUnknownArgumentType]
            return str(result_data)
        return result.message

    @mcp.tool()
    async def skills_run(
        name: str = Field(description="Skill name"),
        command: str = Field(description="Command to execute in skill directory"),
        timeout: int = Field(default=120, description="Maximum execution time in seconds"),
    ) -> str:
        """Run a command inside a skill directory.

        Executes the command with the skill's directory as the working directory,
        so relative paths in scripts work correctly.

        If the skill has a `scripts/pyproject.toml` file, the command will be
        executed in an isolated virtual environment managed by uv. The environment
        is automatically created before execution and destroyed after completion.

        Examples:
        - skills_run(name="gcd-calculator", command="python scripts/gcd.py 12 18")
        - skills_run(name="my-tool", command="bash scripts/setup.sh")
        """
        skill_path = skill_manager.get_skill_path(name)
        if not skill_path:
            return f"Error: skill '{name}' not found"

        # Handle FieldInfo objects from direct calls (not via MCP)
        actual_timeout = timeout if isinstance(timeout, int) else 120

        # Check if scripts/pyproject.toml exists for uv isolation
        scripts_dir = skill_path / "scripts"
        pyproject_path = scripts_dir / "pyproject.toml"

        if pyproject_path.exists():
            # Use uv isolation: create temp venv, install deps, run, cleanup
            # Adjust command path: since cwd will be scripts/, remove "scripts/" prefix
            adjusted_command = command
            if "scripts/" in command:
                adjusted_command = command.replace("scripts/", "")
            
            output, exit_code = await _run_with_uv_isolation(
                scripts_dir=scripts_dir,
                command=adjusted_command,
                timeout=actual_timeout,
            )
            if exit_code != 0:
                return f"Exit code: {exit_code}\n{output}"
            return output

        # No pyproject.toml - use direct execution (backward compatible)
        # Use executor to run command in skill directory
        # Since sandbox_to_skills=True by default, skill directories are
        # directly under workspace_root, so we can use the skill name as cwd
        try:
            # Try to get relative path from workspace root
            rel_path = str(skill_path.relative_to(sandbox.workspace_root))
        except ValueError:
            # Skill is outside workspace (shouldn't happen with sandbox_to_skills)
            # Fall back to skill name if it exists as a directory
            if (sandbox.workspace_root / name).is_dir():
                rel_path = name
            else:
                return (
                    f"Error: Cannot run command in skill '{name}' "
                    f"(path {skill_path} is outside workspace)"
                )

        exec_result = await executor.bash(command, cwd=rel_path, timeout=actual_timeout)
        if exec_result.status == ToolStatus.ERROR:
            return f"Exit code: {exec_result.exit_code}\n{exec_result.output}"
        return exec_result.output

    return {
        "sandbox": sandbox,
        "executor": executor,
        "skill_manager": skill_manager,
    }
